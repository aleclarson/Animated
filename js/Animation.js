// Generated by CoffeeScript 1.12.4
var Animation, NativeAnimated, Number, Type, assertType, emptyFunction, injected, mutable, type;

mutable = require("Property").mutable;

Number = require("Nan").Number;

emptyFunction = require("emptyFunction");

assertType = require("assertType");

Type = require("Type");

NativeAnimated = require("./NativeAnimated");

injected = require("./injectable");

type = Type("Animation");

type.trace();

type.defineStatics({
  types: Object.create(null)
});

type.defineArgs(function() {
  return {
    types: {
      fromValue: Number,
      isInteraction: Boolean,
      useNativeDriver: Boolean
    },
    defaults: {
      isInteraction: true,
      useNativeDriver: false
    }
  };
});

type.initInstance((function() {
  var hasWarned;
  hasWarned = false;
  return function(options) {
    if (options.useNativeDriver) {
      if (NativeAnimated.isAvailable || hasWarned) {
        return;
      }
      options.useNativeDriver = false;
      log.warn("Failed to load NativeAnimatedModule! Falling back to JS-driven animations.");
      hasWarned = true;
    }
  };
})());

type.defineValues(function(options) {
  var ref;
  return {
    startTime: null,
    fromValue: (ref = options.fromValue) != null ? ref : null,
    _state: 0,
    _isInteraction: options.isInteraction,
    _useNativeDriver: options.useNativeDriver,
    _nativeTag: null,
    _lastTime: null,
    _animationFrame: null,
    _previousAnimation: null,
    _onUpdate: emptyFunction,
    _onEnd: emptyFunction,
    _onEndQueue: []
  };
});

type.defineBoundMethods({
  _recomputeValue: function(time) {
    var value;
    this._animationFrame = null;
    if (this.isDone) {
      return;
    }
    if (typeof time !== "number") {
      time = Date.now();
      this.elapsedTime = time - this.startTime;
    } else if (this._lastTime) {
      this.elapsedTime += time - this._lastTime;
    } else {
      this.elapsedTime = Date.now() - this.startTime;
    }
    value = this.__computeValue(time);
    value = Math.round(value * 1e3) / 1e3;
    this.__onAnimationUpdate(value);
    this._lastTime = time;
    if (!this.isDone) {
      this._onUpdate(value);
      this._requestAnimationFrame();
    }
  }
});

type.defineGetters({
  isPending: function() {
    return this._state === 0;
  },
  isActive: function() {
    return this._state === 1;
  },
  isDone: function() {
    return this._state === 2;
  }
});

type.defineHooks({
  __computeValue: null,
  __onAnimationStart: function(animated) {
    if (this._useNativeDriver) {
      return this._startNativeAnimation(animated);
    } else {
      return this._requestAnimationFrame();
    }
  },
  __onAnimationUpdate: emptyFunction,
  __onAnimationEnd: emptyFunction,
  __getNativeConfig: function() {
    throw Error("This animation type does not support native offloading!");
  }
});

type.defineMethods({
  start: function(animated, onUpdate) {
    var animation, id;
    assertType(onUpdate, Function.Maybe);
    if (!this.isPending) {
      return this;
    }
    this._state += 1;
    if (this._isInteraction) {
      id = this._createInteraction();
    }
    if (animation = animated._animation) {
      this._previousAnimation = animation;
      animation.stop();
    }
    if (onUpdate) {
      onUpdate = animated.didSet(onUpdate);
    }
    if (!this._useNativeDriver) {
      this._onUpdate = function(newValue) {
        return animated._updateValue(newValue, false);
      };
    }
    this._onEnd = (function(_this) {
      return function(finished) {
        _this._onEnd = emptyFunction;
        _this._clearInteraction(id);
        _this.__onAnimationEnd(finished);
        animated._animation = null;
        _this._onUpdate = emptyFunction;
        if (onUpdate != null) {
          onUpdate.detach();
        }
        if (_this._useNativeDriver) {
          NativeAnimated.removeUpdateListener(animated);
        }
        _this._flushEndQueue(finished);
      };
    })(this);
    animated._animation = this;
    this._startAnimation(animated);
    return this;
  },
  stop: function(finished) {
    if (finished == null) {
      finished = false;
    }
    assertType(finished, Boolean);
    return this._stopAnimation(finished);
  },
  then: function(onEnd) {
    var queue;
    assertType(onEnd, Function);
    if (queue = this._onEndQueue) {
      queue.push(onEnd);
    }
    return this;
  },
  _requestAnimationFrame: function(callback) {
    return this._animationFrame || (this._animationFrame = injected.call("requestAnimationFrame", callback || this._recomputeValue));
  },
  _cancelAnimationFrame: function() {
    if (this._animationFrame) {
      injected.call("cancelAnimationFrame", this._animationFrame);
      this._animationFrame = null;
    }
  },
  _startAnimation: function(animated) {
    if (this.fromValue != null) {
      animated._updateValue(this.fromValue, this._useNativeDriver);
    } else {
      this.fromValue = animated._value;
    }
    this.startTime = Date.now();
    if (!this._useNativeDriver) {
      mutable.define(this, "elapsedTime", {
        value: 0
      });
    }
    this.__onAnimationStart(animated);
  },
  _startNativeAnimation: function(animated) {
    var animatedTag, animationConfig;
    this._nativeTag = NativeAnimated.createAnimationTag();
    animated.__markNative();
    animatedTag = animated.__getNativeTag();
    animationConfig = this.__getNativeConfig();
    NativeAnimated.addUpdateListener(animated);
    return NativeAnimated.startAnimatingNode(this._nativeTag, animatedTag, animationConfig, (function(_this) {
      return function(data) {
        if (!_this.isDone) {
          _this._state += 1;
          _this._onEnd(data.finished);
        }
      };
    })(this));
  },
  _stopAnimation: function(finished) {
    if (!this.isDone) {
      this._state += 1;
      if (this._nativeTag) {
        NativeAnimated.stopAnimation(this._nativeTag);
      } else {
        this._cancelAnimationFrame();
      }
      this._onEnd(finished);
    }
  },
  _flushEndQueue: function(finished) {
    var i, len, onEnd, queue;
    queue = this._onEndQueue;
    this._onEndQueue = null;
    for (i = 0, len = queue.length; i < len; i++) {
      onEnd = queue[i];
      onEnd(finished);
    }
  },
  _assertNumber: function(value) {
    assertType(value, Number);
  },
  _createInteraction: function() {
    return injected.get("InteractionManager").createInteractionHandle();
  },
  _clearInteraction: function(handle) {
    if (handle != null) {
      injected.get("InteractionManager").clearInteractionHandle(handle);
    }
  }
});

module.exports = Animation = type.build();
