// Generated by CoffeeScript 1.12.4
var AnimatedMap, AnimatedStyle, Children, NativeAnimated, Style, Type, emptyFunction, findNodeHandle, isDev, ref, type;

ref = require("react-validators"), Children = ref.Children, Style = ref.Style;

findNodeHandle = require("react/lib/findNodeHandle");

emptyFunction = require("emptyFunction");

isDev = require("isDev");

Type = require("Type");

NativeAnimated = require("../NativeAnimated");

AnimatedStyle = require("./AnimatedStyle");

AnimatedMap = require("./AnimatedMap");

type = Type("AnimatedProps");

type.inherits(AnimatedMap);

type.defineArgs(function() {
  return {
    required: false,
    types: [Object]
  };
});

type.defineMethods({
  setAnimatedView: function(animatedView) {
    if (this.__isNative && this._animatedView) {
      this._disconnectAnimatedView();
    }
    this._animatedView = animatedView;
    if (this.__isNative && animatedView) {
      this._connectAnimatedView();
    }
  },
  detach: function() {
    if (this.__isNative && this._animatedView) {
      this._disconnectAnimatedView();
    }
    this.__detach();
  }
});

type.defineValues(function(propTypes, onUpdate) {
  return {
    _propTypes: propTypes || {},
    _animatedView: null,
    _isUpdating: false,
    _onUpdate: onUpdate
  };
});

type.overrideMethods({
  __addChild: emptyFunction,
  __removeChild: emptyFunction,
  __attachValue: function(value, key) {
    var style;
    if (this._propTypes) {
      type = this._propTypes[key];
    }
    if (type === Children) {
      this._values[key] = value;
      return;
    }
    if (type === Style && (value != null)) {
      style = this._animatedValues[key] || AnimatedStyle();
      style.attach(value);
      this.__attachAnimatedValue(style, key);
      return;
    }
    this.__super(arguments);
  },
  __markNative: function() {
    if (!NativeAnimated.isAvailable) {
      return;
    }
    if (this.__isNative) {
      return;
    }
    this.__isNative = true;
    if (this._animatedView) {
      this._connectAnimatedView();
    }
  },
  __getNativeConfig: function() {
    var animatedValues, key, props, value;
    props = {};
    animatedValues = this._animatedValues;
    for (key in animatedValues) {
      value = animatedValues[key];
      if (!value.__isNative) {
        continue;
      }
      props[key] = value.__getNativeTag();
    }
    isDev && NativeAnimated.validateProps(props);
    return {
      type: "props",
      props: props
    };
  },
  __didUpdateValue: function(key, value) {
    this._updatedValues[key] = value;
    if (this._isUpdating) {
      return;
    }
    this._isUpdating = true;
    return requestAnimationFrame((function(_this) {
      return function() {
        var props;
        props = _this.__getUpdatedValue();
        _this._isUpdating = false;
        _this._onUpdate(props);
      };
    })(this));
  }
});

type.defineMethods({
  _connectAnimatedView: function() {
    var nodeTag;
    if (!this.__isNative) {
      throw Error("Must call '__markNative' before '_connectAnimatedView'!");
    }
    if (!this._animatedView) {
      throw Error("Must call 'setAnimatedView' before '_connectAnimatedView'!");
    }
    nodeTag = findNodeHandle(this._animatedView);
    NativeAnimated.connectAnimatedNodeToView(this.__getNativeTag(), nodeTag);
  },
  _disconnectAnimatedView: function() {
    if (!this.__isNative) {
      throw Error("Must call '__markNative' before '_disconnectAnimatedView'!");
    }
    NativeAnimated.disconnectAnimatedNodeFromView(this.__getNativeTag());
  }
});

module.exports = type.build();
